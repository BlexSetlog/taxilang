package lang.taxi.generators.typescript

import lang.taxi.TaxiDocument
import lang.taxi.generators.ModelGenerator
import lang.taxi.generators.Processor
import lang.taxi.generators.TaxiProjectEnvironment
import lang.taxi.generators.WritableSource
import lang.taxi.types.ArrayType
import lang.taxi.types.ObjectType
import lang.taxi.types.PrimitiveType
import lang.taxi.types.Type
import java.nio.file.Path
import java.nio.file.Paths

const val staticHeader = """/**
 * This file is generated by the Taxi compiler.
 * Do not edit this file manually.
 */
import { DatatypeContainer, DatatypeName } from 'orbital-client';

function buildDatatypeContainer<V>(name: DatatypeName, value: V): DatatypeContainer<V> {
  return { name, value };
}

function Datatype(type: DatatypeName) {
  return Reflect.metadata('datatype', type);
}

"""

class TypeScriptGenerator : ModelGenerator {
   override fun generate(
      taxi: TaxiDocument,
      processors: List<Processor>,
      environment: TaxiProjectEnvironment
   ): List<WritableSource> {
      return listOf(StringWritableSource(generateCode(taxi.types)))
   }

   private fun generateCode(types: Set<Type>): String {
      val typesByNamespace = types.groupBy { it.toQualifiedName().namespace }
         .filter { (namespace) -> namespace != "taxi.stdlib" } // TODO Skip this in a more elegant way
      val namespaces = typesByNamespace.entries.joinToString("\n\n") { (namespace, types) ->
         generateNamespace(namespace, types)
      }
      val taxonomyObject = generateTaxonomyObject(typesByNamespace.keys)
      return listOf(staticHeader, namespaces, taxonomyObject).joinToString("\n")
   }

   private fun generateTaxonomyObject(keys: Set<String>): String {
      val (global, namespaced) = keys.partition { it == "" }
      val namespaces = namespaced.joinToString(", ") { "$it: new $it.Taxonomy()" }
      val globalDefinitions = global.firstOrNull()?.let {
         "${if (namespaced.isNotEmpty()) ", " else ""}...(new Taxonomy())"
      } ?: ""
      return "export const taxonomy = { $namespaces$globalDefinitions };"
   }

   private fun generateNamespace(namespace: String, types: List<Type>): String {
      val definitions = generateNamespaceContent(types)
      if (namespace == "") {
         return definitions
      }
      return """export namespace $namespace {
${definitions.prependIndent("  ")}
}"""
   }

   private fun generateNamespaceContent(types: List<Type>): String {
      val (typeDefinitions, models) = types.filterIsInstance<ObjectType>().partition { it.inheritsFromPrimitive }
      val taxonomyDefinition = generateTaxonomyClass(typeDefinitions, models)
      val definitions = listOf(
         typeDefinitions.joinToString(separator = "\n") { generateType(it) },
         models.joinToString(separator = "\n") { generateModel(it) },
         taxonomyDefinition
      ).joinToString(separator = "\n")
      return definitions
   }

   private fun generateType(type: ObjectType): String {
      val nameInsideNamespace = type.toQualifiedName().typeName
      val typeAlias = "${nameInsideNamespace}Type"
      return """export type $typeAlias = ${deduceUnderlyingPrimitiveTypeInTypeScript(type)};
export type $nameInsideNamespace = DatatypeContainer<$typeAlias>;"""
   }

   private fun generateModel(model: ObjectType): String {
      val fields = model.fields.joinToString(separator = "; ") { "readonly ${it.name}: ${deduceTypeName(it.type)}" }
      return "export type ${model.toQualifiedName().typeName} = DatatypeContainer<{ $fields }>;"
   }

   private fun generateTaxonomyClass(types: List<ObjectType>, models: List<ObjectType>): String {
      return """export class Taxonomy {
${types.joinToString(separator = "\n") { generateTypePropertyToTaxonomyClass(it).prependIndent("  ") }}
${models.joinToString(separator = "\n") { generateModelPropertyToTaxonomyClass(it).prependIndent("  ") }}
}"""
   }

   private fun generateTypePropertyToTaxonomyClass(type: ObjectType): String {
      /** TODO Using base primitive is probably not right for inheritance use cases like:
       * type Foo inherits string
       * type FooBar inherits Foo
       *
       * Instead FooBar should possibly be able to point to the Foo
       */
      val emptyValue = getEmptyPrimitiveValue(type.basePrimitive!!)
      return """@Datatype('${type.qualifiedName}')
readonly ${type.toQualifiedName().typeName}: ${type.toQualifiedName().typeName} = buildDatatypeContainer('${type.qualifiedName}', $emptyValue);"""
   }

   private fun generateModelPropertyToTaxonomyClass(type: ObjectType): String {
      return """@Datatype('${type.qualifiedName}')
readonly ${type.toQualifiedName().typeName}: ${type.toQualifiedName().typeName} = buildDatatypeContainer('${type.qualifiedName}', {
${generateModelPropertyValueObjectToTaxonomyClass(type).prependIndent("  ")}
});"""
   }

   private fun generateModelPropertyValueObjectToTaxonomyClass(type: ObjectType): String {
      val typeNamespace = type.toQualifiedName().namespace
      return type.fields.joinToString(separator = ",\n") {
         val (fieldType, isArray) = if (it.type is ArrayType) {
            (it.type as ArrayType).memberType.toQualifiedName() to true
         } else {
            it.type.toQualifiedName() to false
         }
         val namespacedThis = if (fieldType.namespace == typeNamespace) "this" else "${fieldType.namespace}.Taxonomy"
         val fieldReference = "$namespacedThis.${fieldType.typeName}"
         val namespacedName = if (isArray) "[$fieldReference]" else fieldReference
         val nullability = if (it.nullable) "?" else ""
         "${it.name}${nullability}: $namespacedName"
      }
   }

   private fun deduceUnderlyingPrimitiveTypeInTypeScript(type: ObjectType): String {
      return getPrimitiveTypeNameInTypeScript(type.basePrimitive!!)
   }

   private fun deduceTypeName(type: Type): String {
      return if (type is PrimitiveType) {
         getPrimitiveTypeNameInTypeScript(type)
      } else if (type is ArrayType) {
         "${type.memberType.qualifiedName}[]"
      } else {
         type.qualifiedName
      }
   }

   private fun getPrimitiveTypeNameInTypeScript(primitiveType: PrimitiveType) =
      when (primitiveType) { // TODO Scalar, not primitive?
         PrimitiveType.STRING -> "string"
         PrimitiveType.INTEGER -> "number"
         PrimitiveType.DECIMAL -> "number"
         PrimitiveType.DOUBLE -> "number"
         PrimitiveType.BOOLEAN -> "boolean"
         PrimitiveType.TIME -> "Date"
         PrimitiveType.INSTANT -> "Date"
         PrimitiveType.DATE_TIME -> "Date"
         else -> "unknown"
      }

   private fun getEmptyPrimitiveValue(primitiveType: PrimitiveType) = when (primitiveType) {
      PrimitiveType.STRING -> "''"
      PrimitiveType.INTEGER -> "0"
      PrimitiveType.DECIMAL -> "0.0"
      PrimitiveType.DOUBLE -> "0.0"
      PrimitiveType.BOOLEAN -> "false"
      PrimitiveType.TIME -> "new Date()"
      PrimitiveType.INSTANT -> "new Date()"
      PrimitiveType.DATE_TIME -> "new Date()"
      else -> "null"
   }
}

data class StringWritableSource(override val content: String) : WritableSource {
   override val path: Path = Paths.get("taxonomy.ts")
}
