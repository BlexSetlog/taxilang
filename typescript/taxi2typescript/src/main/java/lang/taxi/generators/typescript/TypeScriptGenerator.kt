package lang.taxi.generators.typescript

import lang.taxi.TaxiDocument
import lang.taxi.generators.ModelGenerator
import lang.taxi.generators.Processor
import lang.taxi.generators.TaxiProjectEnvironment
import lang.taxi.generators.WritableSource
import lang.taxi.types.ObjectType
import lang.taxi.types.PrimitiveType
import lang.taxi.types.QualifiedName
import java.nio.file.Path
import java.nio.file.Paths

private val STATIC_CONTENT = """
/**
 * This file is generated by the Taxi compiler.
 * Do not edit this file manually.
 */
import { DatatypeContainer, DatatypeName } from 'vyne-ts';

function buildDatatypeContainer<V>(name: DatatypeName, value: V): DatatypeContainer<V> {
  return { name, value };
}

function Datatype(type: DatatypeName) {
  return Reflect.metadata('datatype', type);
}

""".trimIndent()

private fun QualifiedName.asContainer() = "${this}Container"

class TypeScriptGenerator : ModelGenerator {
   override fun generate(
      taxi: TaxiDocument,
      processors: List<Processor>,
      environment: TaxiProjectEnvironment
   ): List<WritableSource> {
      val types = taxi.types.filter { it is ObjectType && it.inheritsFromPrimitive } as List<ObjectType>
      val models = taxi.types.filter { it is ObjectType && !it.inheritsFromPrimitive } as List<ObjectType>
      return listOf(StringWritableSource(generateCode(types, models)))
   }

   private fun generateCode(types: List<ObjectType>, models: List<ObjectType>): String {
      val typeDefinitions = types.map { generateType(it) }.joinToString(separator = "\n")
      val modelDefinitions = models.map { generateModel(it) }.joinToString(separator = "\n")
      val taxonomyDefinition = generateTaxonomyClass(types, models)

      return listOf(STATIC_CONTENT, typeDefinitions, modelDefinitions, taxonomyDefinition).joinToString(separator = "\n")
   }

   private fun generateType(type: ObjectType): String {
      val qualifiedName = type.toQualifiedName()
      val typeAlias = """$qualifiedName"""
      return """
         export type $typeAlias = ${getPrimitiveTypeNameInTypeScript(type.basePrimitive!!)};
         export type ${qualifiedName.asContainer()} = DatatypeContainer<$typeAlias>;

      """.trimIndent()
   }

   private fun generateModel(model: ObjectType): String {
      return "export type ${model.toQualifiedName().asContainer()} = DatatypeContainer<{ ${model.fields.map { "readonly ${it.name}: ${it.type.toQualifiedName().asContainer()}" }.joinToString(separator = "; ")} }>;\n"
   }

   private fun generateTaxonomyClass(types: List<ObjectType>, models: List<ObjectType>): String {
      return """
         export class Taxonomy {
            ${types.map { generateTypePropertyToTaxonomyClass(it) }.joinToString(separator = "\n\n")}
            ${models.map { generateModelPropertyToTaxonomyClass(it) }.joinToString(separator = "\n\n")}
         }
      """.trimIndent()
   }

   private fun generateTypePropertyToTaxonomyClass(type: ObjectType): String {
      val qualifiedName = type.toQualifiedName()
      val emptyValue = getEmptyPrimitiveValue(type.inheritsFrom.first() as PrimitiveType)
      return """
         @Datatype('$qualifiedName')
         readonly $qualifiedName: ${qualifiedName.asContainer()} = buildDatatypeContainer('$qualifiedName', $emptyValue);
      """.trimIndent().prependIndent("  ")
   }

   private fun generateModelPropertyToTaxonomyClass(type: ObjectType): String {
      val qualifiedName = type.toQualifiedName()
      return """
         @Datatype('$qualifiedName')
         readonly $qualifiedName: ${qualifiedName.asContainer()} = buildDatatypeContainer('$qualifiedName', {
            ${generateModelPropertyValueObjectToTaxonomyClass(type)}
         });
      """.trimIndent().prependIndent("  ")
   }

   private fun generateModelPropertyValueObjectToTaxonomyClass(type: ObjectType): String {
      return type.fields.map { "${it.name}: this.${it.type.toQualifiedName()}" }.joinToString(separator = ",\n")
   }

   private fun getPrimitiveTypeNameInTypeScript(primitiveType: PrimitiveType) = when (primitiveType) {
      PrimitiveType.STRING -> "string"
      PrimitiveType.INTEGER -> "number"
      PrimitiveType.DECIMAL -> "number"
      PrimitiveType.DOUBLE -> "number"
      PrimitiveType.BOOLEAN -> "boolean"
      PrimitiveType.TIME -> "Date"
      PrimitiveType.INSTANT -> "Date"
      PrimitiveType.DATE_TIME -> "Date"
      else -> "unknown"
   }

   private fun getEmptyPrimitiveValue(primitiveType: PrimitiveType) = when (primitiveType) {
      PrimitiveType.STRING -> "''"
      PrimitiveType.INTEGER -> "0"
      PrimitiveType.DECIMAL -> "0.0"
      PrimitiveType.DOUBLE -> "0.0"
      PrimitiveType.BOOLEAN -> "false"
      PrimitiveType.TIME -> "new Date()"
      PrimitiveType.INSTANT -> "new Date()"
      PrimitiveType.DATE_TIME -> "new Date()"
      else -> "null"
   }
}

data class StringWritableSource(override val content: String) : WritableSource {
   override val path: Path = Paths.get("taxonomy.ts")
}
