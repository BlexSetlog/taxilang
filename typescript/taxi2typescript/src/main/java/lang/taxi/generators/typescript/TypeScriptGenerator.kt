package lang.taxi.generators.typescript

import lang.taxi.TaxiDocument
import lang.taxi.generators.ModelGenerator
import lang.taxi.generators.Processor
import lang.taxi.generators.TaxiProjectEnvironment
import lang.taxi.generators.WritableSource
import lang.taxi.types.ArrayType
import lang.taxi.types.ObjectType
import lang.taxi.types.PrimitiveType
import lang.taxi.types.Type
import java.nio.file.Path
import java.nio.file.Paths

const val staticHeader = """/**
 * This file is generated by the Taxi compiler.
 * Do not edit this file manually.
 */
import { DatatypeContainer, DatatypeName } from 'orbital-client';

function buildDatatypeContainer<V>(name: DatatypeName, value: V): DatatypeContainer<V> {
  return { name, value };
}

function Datatype(type: DatatypeName) {
  return Reflect.metadata('datatype', type);
}

"""

class TypeScriptGenerator : ModelGenerator {
   override fun generate(
      taxi: TaxiDocument,
      processors: List<Processor>,
      environment: TaxiProjectEnvironment
   ): List<WritableSource> {
      return listOf(StringWritableSource(generateCode(taxi.types)))
   }

   private fun generateCode(types: Set<Type>): String {
      val typesByNamespace = types.groupBy { it.toQualifiedName().namespace }
         .filter { (namespace) -> namespace != "taxi.stdlib" } // TODO Skip this in a more elegant way
      val namespaces = typesByNamespace.entries.joinToString("\n\n") { (namespace, types) ->
         generateNamespace(namespace, types)
      }
      val taxonomyObject = generateTaxonomyObject(typesByNamespace.keys)
      return listOf(staticHeader, namespaces, taxonomyObject).joinToString("\n")
   }

   private fun generateTaxonomyObject(keys: Set<String>): String {
      val (global, namespaced) = keys.partition { it == "" }
      val namespaces = generateNamespaceMapping(keys)
      val globalDefinitions = global.firstOrNull()?.let {
         "${if (namespaced.isNotEmpty()) ", " else ""}...(new Taxonomy())"
      } ?: ""
      return "export const taxonomy = { $namespaces$globalDefinitions };"
   }

   private fun generateNamespaceMapping(keys: Set<String>): String {
      val namespaceMap =
         keys.map { it.split(".") }
            .fold(mutableMapOf<String, Any>()) { acc, item -> convertNamespaceKeysToMap(acc, item) }

      return generateSpecificNamespace(namespaceMap.entries)
   }

   private fun generateSpecificNamespace(entries: Set<Map.Entry<String, Any>>, namespacePrefix: String = ""): String {
      if (entries.isEmpty()) {
         return ""
      }

      return entries.joinToString(", ") {
         val newNamespacePrefix = if (namespacePrefix.isNotEmpty()) "$namespacePrefix.${it.key}" else it.key
         val subNamespaces =
            generateSpecificNamespace((it.value as Map<String, Any>).entries, newNamespacePrefix)
         val foo = if (subNamespaces.isNotEmpty()) "$subNamespaces, " else ""
         "${it.key}: { $foo...(new $newNamespacePrefix.Taxonomy()) }"
      }
   }

   /**
    * Transforms the namespace keys (e.g. "animals.pets.dogs") into a nested map of maps
    * ({ animals: { pets: { dogs: {} } } } to be able to print all of them properly
    */
   private fun convertNamespaceKeysToMap(
      map: MutableMap<String, Any>,
      namespaceParts: List<String>
   ): MutableMap<String, Any> {
      val key = namespaceParts.first()
      val isKeyAlreadyDefined = map.containsKey(key)
      if (!isKeyAlreadyDefined) {
         map[key] = mutableMapOf<String, Any>()
      }
      if (namespaceParts.size == 1) {
         return map
      }
      val rest = namespaceParts.slice(1..namespaceParts.lastIndex)
      convertNamespaceKeysToMap(map[key] as MutableMap<String, Any>, rest)

      return map
   }

   private fun generateNamespace(namespace: String, types: List<Type>): String {
      val definitions = generateNamespaceContent(types)
      if (namespace == "") {
         return definitions
      }
      return """export namespace $namespace {
${definitions.prependIndent("  ")}
}"""
   }

   private fun generateNamespaceContent(types: List<Type>): String {
      val (typeDefinitions, models) = types.filterIsInstance<ObjectType>().partition { it.inheritsFromPrimitive }
      val taxonomyDefinition = generateTaxonomyClass(typeDefinitions, models)
      val definitions = listOf(
         typeDefinitions.joinToString(separator = "\n") { generateType(it) },
         models.joinToString(separator = "\n") { generateModel(it) },
         taxonomyDefinition
      ).joinToString(separator = "\n")
      return definitions
   }

   private fun generateType(type: ObjectType): String {
      val nameInsideNamespace = type.toQualifiedName().typeName
      val typeAlias = "${nameInsideNamespace}Type"
      return """export type $typeAlias = ${deduceUnderlyingPrimitiveTypeInTypeScript(type)};
export type $nameInsideNamespace = DatatypeContainer<$typeAlias>;"""
   }

   private fun generateModel(model: ObjectType): String {
      val fields = model.fields.joinToString(separator = "; ") { "readonly ${it.name}: ${deduceTypeName(it.type)}Type" }
      return "export type ${model.toQualifiedName().typeName} = DatatypeContainer<{ $fields }>;"
   }

   private fun generateTaxonomyClass(types: List<ObjectType>, models: List<ObjectType>): String {
      return """export class Taxonomy {
${types.joinToString(separator = "\n") { generateTypePropertyToTaxonomyClass(it).prependIndent("  ") }}
${models.joinToString(separator = "\n") { generateModelPropertyToTaxonomyClass(it).prependIndent("  ") }}
}"""
   }

   private fun generateTypePropertyToTaxonomyClass(type: ObjectType): String {
      /** TODO Using base primitive is probably not right for inheritance use cases like:
       * type Foo inherits string
       * type FooBar inherits Foo
       *
       * Instead FooBar should possibly be able to point to the Foo
       */
      val emptyValue = getEmptyPrimitiveValue(type.basePrimitive!!)
      return """readonly ${type.toQualifiedName().typeName}: ${type.toQualifiedName().typeName} = buildDatatypeContainer('${type.qualifiedName}', $emptyValue);"""
   }

   private fun generateModelPropertyToTaxonomyClass(type: ObjectType): String {
      return """readonly ${type.toQualifiedName().typeName}: ${type.toQualifiedName().typeName} = buildDatatypeContainer('${type.qualifiedName}', {
${generateModelPropertyValueObjectToTaxonomyClass(type).prependIndent("  ")}
});"""
   }

   private fun generateModelPropertyValueObjectToTaxonomyClass(type: ObjectType): String {
      return type.fields.joinToString(separator = ",\n") {
         val isArray = it.type is ArrayType // TODO Handle arrays?
         val value = getEmptyPrimitiveValue(it.type.basePrimitive!!)
         val nullability = if (it.nullable) "?" else ""
         "${it.name}${nullability}: $value"
      }
   }

   private fun deduceUnderlyingPrimitiveTypeInTypeScript(type: ObjectType): String {
      return getPrimitiveTypeNameInTypeScript(type.basePrimitive!!)
   }

   private fun deduceTypeName(type: Type): String {
      return if (type is PrimitiveType) {
         getPrimitiveTypeNameInTypeScript(type)
      } else if (type is ArrayType) {
         "${type.memberType.qualifiedName}[]"
      } else {
         type.qualifiedName
      }
   }

   private fun getPrimitiveTypeNameInTypeScript(primitiveType: PrimitiveType) =
      when (primitiveType) { // TODO Scalar, not primitive?
         PrimitiveType.STRING -> "string"
         PrimitiveType.INTEGER -> "number"
         PrimitiveType.DECIMAL -> "number"
         PrimitiveType.DOUBLE -> "number"
         PrimitiveType.BOOLEAN -> "boolean"
         PrimitiveType.TIME -> "Date"
         PrimitiveType.INSTANT -> "Date"
         PrimitiveType.DATE_TIME -> "Date"
         else -> "unknown"
      }

   private fun getEmptyPrimitiveValue(primitiveType: PrimitiveType) = when (primitiveType) {
      PrimitiveType.STRING -> "''"
      PrimitiveType.INTEGER -> "0"
      PrimitiveType.DECIMAL -> "0.0"
      PrimitiveType.DOUBLE -> "0.0"
      PrimitiveType.BOOLEAN -> "false"
      PrimitiveType.TIME -> "new Date()"
      PrimitiveType.INSTANT -> "new Date()"
      PrimitiveType.DATE_TIME -> "new Date()"
      else -> "null"
   }
}

data class StringWritableSource(override val content: String) : WritableSource {
   override val path: Path = Paths.get("taxonomy.ts")
}

data class NamespaceFoo(val name: String, val children: MutableList<NamespaceFoo> = mutableListOf())
