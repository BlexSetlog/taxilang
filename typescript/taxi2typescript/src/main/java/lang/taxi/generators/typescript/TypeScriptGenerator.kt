package lang.taxi.generators.typescript

import lang.taxi.TaxiDocument
import lang.taxi.generators.ModelGenerator
import lang.taxi.generators.Processor
import lang.taxi.generators.TaxiProjectEnvironment
import lang.taxi.generators.WritableSource
import lang.taxi.types.ArrayType
import lang.taxi.types.Arrays
import lang.taxi.types.ObjectType
import lang.taxi.types.PrimitiveType
import lang.taxi.types.Type
import lang.taxi.utils.log
import java.nio.file.Path
import java.nio.file.Paths

const val staticHeader = """/**
 * This file is generated by the Taxi compiler.
 * Do not edit this file manually.
 */
import { DatatypeContainer, DatatypeName } from '@orbitalhq/orbital-client';

function buildDatatypeContainer<V>(name: DatatypeName, value: V): DatatypeContainer<V> {
  return { name, value };
}

function Datatype(type: DatatypeName) {
  return Reflect.metadata('datatype', type);
}

"""

class TypeScriptGenerator : ModelGenerator {
   companion object {
      private val excludedNamespaces = listOf(
         "taxi.stdlib",
      )
   }

   override fun generate(
      taxi: TaxiDocument,
      processors: List<Processor>,
      environment: TaxiProjectEnvironment
   ): List<WritableSource> {
      return listOf(StringWritableSource(generateCode(taxi.types)))
   }

   private fun generateCode(types: Set<Type>): String {
      val typesByNamespace = types.groupBy { it.toQualifiedName().namespace }
         .filter { (namespace) -> excludedNamespaces.none { excludedNamespace -> namespace.startsWith(excludedNamespace) } }
      val namespaces = typesByNamespace.entries.joinToString("\n\n") { (namespace, types) ->
         generateNamespace(namespace, types)
      }
      val taxonomyObject = generateTaxonomyObject(typesByNamespace.keys)
      return listOf(staticHeader, namespaces, taxonomyObject).joinToString("\n")
   }

   private fun generateTaxonomyObject(keys: Set<String>): String {
      val (global, namespaced) = keys.partition { it == "" }
      val namespaces = generateNamespaceMapping(keys)
      val globalDefinitions = global.firstOrNull()?.let {
         "${if (namespaced.isNotEmpty()) ", " else ""}...(new Taxonomy())"
      } ?: ""
      return """export const taxonomy = {
$namespaces$globalDefinitions
};"""
   }

   private fun generateNamespaceMapping(namespaces: Set<String>): String {
      val namespaceMap =
         namespaces.map { it.split(".") }
            .fold(mutableMapOf<String, Any>()) { acc, item -> convertNamespaceKeysToMap(acc, item) }

      return generateSpecificNamespace(namespaceMap.entries, definedNamespaces = namespaces, depth = 1)
   }

   private fun generateSpecificNamespace(
      entries: Set<Map.Entry<String, Any>>,
      namespacePrefix: String = "",
      definedNamespaces: Set<String>,
      depth: Int = 0
   ): String {
      if (entries.isEmpty()) {
         return ""
      }

      return entries
         .filter { (key, value) -> !key.isNullOrEmpty() && value != null }
         .joinToString(",\n ") {
            val newNamespacePrefix = if (namespacePrefix.isNotEmpty()) "$namespacePrefix.${it.key}" else it.key
            val childNamespaces =
               generateSpecificNamespace(
                  (it.value as Map<String, Any>).entries,
                  newNamespacePrefix,
                  definedNamespaces,
                  depth + 1
               )
            val childrenNamespacePreamble = if (childNamespaces.isNotEmpty()) "$childNamespaces, " else ""
            val indentPrefix = " ".repeat(depth * 2)
            val thisNamespaceTaxonomyDefinition = if (definedNamespaces.contains(newNamespacePrefix)) {
               "...(new $newNamespacePrefix.Taxonomy())".prependIndent(indentPrefix)
            } else ""
            """${it.key}: {
$childrenNamespacePreamble $thisNamespaceTaxonomyDefinition
}""".prependIndent(indentPrefix)
         }
   }

   /**
    * Transforms the namespace keys (e.g. "animals.pets.dogs") into a nested map of maps
    * ({ animals: { pets: { dogs: {} } } } to be able to print all of them properly
    */
   private fun convertNamespaceKeysToMap(
      createdKeys: MutableMap<String, Any>,
      namespaceParts: List<String>
   ): MutableMap<String, Any> {
      val key = namespaceParts.first()
      val isKeyAlreadyDefined = createdKeys.containsKey(key)
      if (!isKeyAlreadyDefined) {
         createdKeys[key] = mutableMapOf<String, Any>()
      }
      if (namespaceParts.size == 1) {
         return createdKeys
      }
      val rest = namespaceParts.slice(1..namespaceParts.lastIndex)
      convertNamespaceKeysToMap(createdKeys[key] as MutableMap<String, Any>, rest)

      return createdKeys
   }

   private fun generateNamespace(namespace: String, types: List<Type>): String {
      val definitions = generateNamespaceContent(types)
      if (namespace.isNullOrEmpty()) {
         return definitions
      }
      return """export namespace $namespace {
${definitions.prependIndent("  ")}
}"""
   }

   private fun generateNamespaceContent(types: List<Type>): String {
      val (typeDefinitions, models) = types.filterIsInstance<ObjectType>().partition { it.inheritsFromPrimitive }
      val taxonomyDefinition = generateTaxonomyClass(typeDefinitions, models)
      val definitions = listOf(
         typeDefinitions.joinToString(separator = "\n") { generateType(it) },
         models.joinToString(separator = "\n") { generateModel(it) },
         taxonomyDefinition
      ).joinToString(separator = "\n")
      return definitions
   }

   private fun generateType(type: ObjectType): String {
      val nameInsideNamespace = type.toQualifiedName().typeName
      val typeAlias = "${nameInsideNamespace}Type"
      return """export type $typeAlias = ${deduceUnderlyingPrimitiveTypeInTypeScript(type)};
export type $nameInsideNamespace = DatatypeContainer<$typeAlias>;"""
   }

   private fun generateModel(model: ObjectType): String {
      val fields = model.fields.joinToString(separator = ";\n") { field ->
         val optional = if (field.nullable) {
            "?"
         } else "";

         // TODO  :What is this TypeSuffix?
         // Checking for arrays b/c we're otherwise generating:
         // { readonly friends: Person[]Type }
         // which is incorrect.  Should it be PersonType[] though?
         val typeSuffix = when {
            Arrays.isArray(field.type) -> ""
            PrimitiveType.isPrimitiveType(field.type.qualifiedName) -> ""
            else -> "Type"
         }
         "readonly ${field.name}$optional: ${deduceTypeName(field.type)}$typeSuffix"
      }.removeSuffix("\n");
      return "export type ${model.toQualifiedName().typeName} = DatatypeContainer<{ $fields }>;"
   }

   private fun generateTaxonomyClass(types: List<ObjectType>, models: List<ObjectType>): String {
      return """export class Taxonomy {
${types.joinToString(separator = "\n") { generateTypePropertyToTaxonomyClass(it).prependIndent("  ") }}
${models.joinToString(separator = "\n") { generateModelPropertyToTaxonomyClass(it).prependIndent("  ") }}
}"""
   }

   private fun generateTypePropertyToTaxonomyClass(type: ObjectType): String {
      /** TODO Using base primitive is probably not right for inheritance use cases like:
       * type Foo inherits string
       * type FooBar inherits Foo
       *
       * Instead FooBar should possibly be able to point to the Foo
       */
      val emptyValue = getEmptyPrimitiveValue(type.basePrimitive!!)
      return """readonly ${type.toQualifiedName().typeName}: ${type.toQualifiedName().typeName} = buildDatatypeContainer('${type.qualifiedName}', $emptyValue);"""
   }

   private fun generateModelPropertyToTaxonomyClass(type: ObjectType): String {
      return """readonly ${type.toQualifiedName().typeName}: ${type.toQualifiedName().typeName} = buildDatatypeContainer('${type.qualifiedName}', {
${generateModelPropertyValueObjectToTaxonomyClass(type).prependIndent("  ")}
});"""
   }

   private fun generateModelPropertyValueObjectToTaxonomyClass(type: ObjectType): String {
      return type.fields.mapNotNull { field ->
         val fieldType = Arrays.unwrapPossibleArrayType(field.type)

         // We need to support init of values for nested fields.
         // Arrays are find (foo = []), but need to solve for object types
         if (!Arrays.isArray(field.type) && fieldType.basePrimitive == null) {
            log().warn("Field ${field.name} on ${type.toQualifiedName().fullyQualifiedName} is of type ${fieldType.qualifiedName} which does not have a base primitive type. (Probably an object).  This isn't yet supported, so this field will be skipped.  ")
            return@mapNotNull null
         }
         val fieldInitializationValue = when {
            Arrays.isArray(field.type) -> "[]"
            else -> getEmptyPrimitiveValue(fieldType.basePrimitive!!)
         }
         "${field.name}: $fieldInitializationValue"
      }.joinToString(",\n")
   }

   private fun deduceUnderlyingPrimitiveTypeInTypeScript(type: ObjectType): String {
      return getPrimitiveTypeNameInTypeScript(type.basePrimitive!!)
   }

   private fun deduceTypeName(type: Type): String {
      return if (type is PrimitiveType) {
         getPrimitiveTypeNameInTypeScript(type)
      } else if (type is ArrayType) {
         "${type.memberType.qualifiedName}[]"
      } else {
         type.qualifiedName
      }
   }

   private fun getPrimitiveTypeNameInTypeScript(primitiveType: PrimitiveType) =
      when (primitiveType) { // TODO Scalar, not primitive?
         PrimitiveType.STRING -> "string"
         PrimitiveType.INTEGER -> "number"
         PrimitiveType.DECIMAL -> "number"
         PrimitiveType.DOUBLE -> "number"
         PrimitiveType.BOOLEAN -> "boolean"
         PrimitiveType.TIME -> "Date"
         PrimitiveType.INSTANT -> "Date"
         PrimitiveType.DATE_TIME -> "Date"
         else -> "unknown"
      }

   private fun getEmptyPrimitiveValue(primitiveType: PrimitiveType) = when (primitiveType) {
      PrimitiveType.STRING -> "''"
      PrimitiveType.INTEGER -> "0"
      PrimitiveType.DECIMAL -> "0.0"
      PrimitiveType.DOUBLE -> "0.0"
      PrimitiveType.BOOLEAN -> "false"
      PrimitiveType.TIME -> "new Date()"
      PrimitiveType.INSTANT -> "new Date()"
      PrimitiveType.DATE_TIME -> "new Date()"
      else -> "null"
   }
}

data class StringWritableSource(override val content: String) : WritableSource {
   override val path: Path = Paths.get("taxonomy.ts")
}

data class NamespaceFoo(val name: String, val children: MutableList<NamespaceFoo> = mutableListOf())
