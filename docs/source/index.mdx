---
title: Overview
description: Explore the Taxi language and ecosystem
---

import DocsetMenu from './components/docset-menu';
import { MenuWrapper } from './components/menu';
import WorkoutMenuItem from './components/workout-menu-item';
import { Button } from '@apollo/space-kit/Button';
import { IconRobot1 } from '@apollo/space-kit/icons/IconRobot1';
import { Link } from 'gatsby';
import { colors } from 'gatsby-theme-apollo-core';
import {
  ExpansionPanel,
} from 'gatsby-theme-apollo-docs/src/components/expansion-panel';

<!--import { ReactComponent as BadmintonPlayer } from './assets/badminton-player.svg';-->
<!--import { ReactComponent as Paragliding } from './assets/paragliding.svg';-->
<!--import { ReactComponent as Weightlift } from './assets/weightlift.svg';-->
<!--import { ReactComponent as Diving } from './assets/diving.svg';-->
<!--import { ReactComponent as HeadLight } from './assets/head-light.svg';-->

Welcome! ðŸ‘‹ Taxi is a language for documenting data - such as data models - and the contracts of APIs.

Taxi describes data semantically, which allows powerful tooling to discover and map data based on it's meaning, rather than the name of a field.

![](https://img.shields.io/badge/dynamic/xml.svg?label=Taxi&url=http%3A%2F%2Frepo.vyne.co%2Frelease%2Forg%2Ftaxilang%2Fparent%2Fmaven-metadata.xml&query=%2F%2Frelease&colorB=green&prefix=v&style=for-the-badge&logo=kotlin&logoColor=white)

## Example
Taxi allows you to be really expressive about what the meaning is of data returned from an API.  By describing the **meaning**  of our data, we can start to make data interchangeable.

For example:
```
model Customer {
   id : CustomerId inherits String
   firstName : FirstName inherits String
   lastName : LastName inherits String
}

model Invoice {
   invoiceId : InvoiceId inherits Int
   customerId : CustomerId
}
```

Those `String`s now have a little more meaning.  And look - we now know that `Invoice.customerId` and `Customer.id` describe the same piece of information - a `CustomerId`.

By building out this set of terms - we create a Taxonomy of interchangeable types.  This allows us to better document how data is intended to be used.  Tooling such as [Vyne](https://vyne.co)
can leverage this to link and discover data automatically, and automate API integration.


```
@HttpOperation(method = "GET", url = "http://myApp/customers/{id}")
operation getPerson(id: CustomerId):Customer
```

## Language Goals

As a language, Taxi focuses on:

* **Readability**  - A familiar syntax that should be easy to write, and easy to understand.
* **Expressiveness** - Taxi should be able to describe the semantic meaning of your data, and rich quirky contracts of our APIs
* **Typesafe** - A strongly typed, expressive language, purpose-built for describing API operations & types
* **Tooling** - Taxi is intended to allow next-generation tooling integration - the syntax allows rich expression of what services can do \(rather than just where to find them\).
* **Extensibility** - Taxi allows you to refine and compose API schemas, adding context, annotations, and improving type signatures.

Taxi is used heavily to power [Vyne](https://vyne.co) - and the projects have influenced each other & evolved together.    The expressiveness of Taxi allows Vyne to automate integration between services.

However, Taxi is intended to be a standalone tool, and is not coupled to Vyne.  There's lots of amazing things you can do with Taxi on it's own.


## New to Taxi or Vyne?

It's easy to adopt Taxi incrementally, meaning you can set it up alongside an existing solution (such as Swagger or XML schemas) and migrate functionality at your convenience.

In fact, Taxi is designed to complement those tools, and you can happily use Swagger or XSDs are you base schema, and then overlay semantic data using Taxi.
